# مراجعة معمارية: تحسين أداء وتوسعية قاعدة البيانات Firestore

## 1. تحليل الوضع الحالي
يعتمد التطبيق حالياً على جلب المجموعات الكاملة (Full Collections) ومعالجتها في جانب العميل (Client-side filtering). هذا الأسلوب يستهلك موارد الجهاز والبيانات، ومع تزايد عدد الفواتير والقيود سيؤدي إلى بطء ملحوظ في الاستجابة.

## 2. استراتيجيات تحسين هيكلية البيانات (Denormalization)
لتقليل عدد الاستعلامات (Joins) وزيادة السرعة:
- **تكرار البيانات الهامة**: إضافة اسم المنتج وسعته مباشرة في وثيقة `StockEntry` و `Invoice.items`. هذا يلغي الحاجة لجلب وثيقة المنتج في كل مرة نعرض فيها السجل.
- **تخزين الأرصدة التراكمية (Aggregated Data)**: بدلاً من حساب المخزون عن طريق جمع آلاف الحركات، يفضل إضافة حقل `currentStock` في وثيقة `ProductVariant` وتحديثه عند كل حركة مخزنية.

## 3. تحسين الاستعلامات والفهرسة (Indexing & Query Optimization)
- **الفلترة في جانب الخادم**: استبدال منطق `.filter { ... }` في Kotlin باستعلامات Firestore المباشرة باستخدام `.whereEqualTo()`.
- **الفهارس المركبة (Composite Indexes)**: تفعيل الفهارس التي تجمع بين (المستودع + التاريخ + الحالة) لضمان استرجاع البيانات بسرعة ثابتة (O(1) relative to collection size).
- **تجنب المسح الكامل**: عدم استخدام `addSnapshotListener` على مجموعات كبيرة بدون قيود `limit()` أو فلاتر قوية.

## 4. نظام الصفحات (Pagination Strategy)
- الانتقال إلى **Cursor-based Pagination** باستخدام `startAfter(DocumentSnapshot)`.
- جلب البيانات على دفعات (مثلاً 20 فاتورة في كل مرة) وتحميل المزيد عند التمرير لأسفل. هذا يضمن سرعة التحميل الأولية مهما كان حجم البيانات الكلي.

## 5. العمليات الحسابية والتقارير (Server-side Aggregation)
- استخدام ميزة **Firestore Aggregation Queries** (`count()`, `sum()`) لحساب إجمالي الذمم أو عدد الطلبات المعلقة مباشرة من الخادم دون الحاجة لتحميل الوثائق.
- تفعيل **Cloud Functions** لإجراء الحسابات المعقدة في الخلفية وتحديث وثائق "التقارير اليومية" بشكل استباقي.

## 6. استراتيجية الأرشفة (Archiving)
- **التقسيم الزمني**: نقل الفواتير المدفوعة والقديمة (أكثر من سنة) إلى مجموعة `archived_invoices`.
- **ملخصات الفترات**: عند انتهاء السنة المالية، يتم إنشاء وثيقة ملخص للرصيد الافتتاحي (Opening Balance) وحذف التفاصيل اليومية القديمة إذا لزم الأمر لتوفير المساحة والحفاظ على سرعة الاستعلامات النشطة.

## 7. الكاش (Caching & Offline Support)
- الاستفادة من **Firestore Offline Persistence** للعمليات الأساسية.
- استخدام **Room Database** كمستودع محلي للتقارير المعقدة التي تتطلب عمليات Join صعبة على Firestore، حيث يتم مزامنة البيانات من Firestore إلى Room في الخلفية.

## 8. الجاهزية لإصدار الويب (Web Readiness)
- المعمارية الحالية (MVVM + Repository Pattern) تدعم الويب بشكل جيد.
- يجب التأكد من أن منطق الوصول للبيانات لا يعتمد على مكتبات أندرويد حصرية لضمان سهولة مشاركة الكود (Kotlin Multiplatform) في المستقبل.

---
**ملاحظة التحديث**: تم توسيع نطاق هذه التحسينات لتشمل كافة السجلات الحيوية في التطبيق (الفواتير، سجل المنتج، سجل البطاريات القديمة، الخزينة، والبنك) لضمان ثبات الأداء في جميع أقسام النظام.
